[{"path":"https://bailey-lab.github.io/coiaf/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 coiaf authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_coi_prediction.html","id":"method-1","dir":"Articles","previous_headings":"","what":"Method 1","title":"Example COI prediction","text":"first approach manuscript document estimating COI shown . works using mean number variant sites, binned groups increasing PLAF infer COI.  , intercept PLAF = 0.5 gives us easy way estimate COI, COI = 1 + log_0.5(1-WSAF), WSAF = 1 - 0.5^(COI-1). However, differences COI PLAF = 0.5 become geometrically smaller. Larger gaps can found different COI, smaller PLAF:","code":"# Loop over range of COIs end_coi <- list() opt_coi <- list() par(mar = c(4, 4, 4, 4)) par(mfrow = c(3, 2)) for (k in 2:7) {    # Simulate data and subset to heterozygous sites only   set.seed(1)   sim1 <- sim_biallelic(coi = k, plaf = p)    # Plot raw WSAF as gray dots   plot(sim1$data$plaf, sim1$data$wsaf,     pch = 20, cex = 0.5, col = \"gray\", ylim = c(0, 1),     xlab = \"PLAF\", ylab = \"WSAF\", main = paste(\"COI =\", k)   )    # Overlay analytical expectations for COI of 2:7   p_vec <- seq(0, 0.5, l = 101)   theory_cois <- theoretical_coi(seq(1, 7), p_vec)   for (i in 1:7) {     lines(p_vec, theory_cois[[paste(\"coi_\", i, sep = \"\")]],       col = \"red\", lwd = 2     )   }   text(     x = rep(0.505, 6), y = 1 - 0.5^(1:6), labels = 1:7,     col = \"red\", cex = 0.6   )    # Compute windowed averages over WSAF and overlay in blue   df_grouped <- process_sim(sim1)    lines(df_grouped$data$midpoints, df_grouped$data$m_variant,     col = \"blue\", lwd = 2, type = \"o\", pch = 20   )    # Predict the COI and print the results   calc_coi <- compute_coi(sim1, \"sim\", max_coi = 50, seq_error = 0.01)   end_coi <- unlist(c(end_coi, calc_coi$coi))    # COI using optimization   add <- optimize_coi(sim1, \"sim\", max_coi = 10)   opt_coi <- unlist(c(opt_coi, add)) } par(mar = c(4, 4, 4, 4)) par(mfrow = c(3, 3)) p_vec <- seq(0, 0.5, l = 101) y <- list() for (k in 1:10) {   y[[k]] <- theoretical_coi(k, p_vec)[[1]]    if (k > 1) {     new_y <- y[[k]] - y[[k - 1]]     plot(p_vec, new_y,       ylab = glue::glue(\"Difference between COI {k-1} and {k}\"),       xlab = \"PLAF\",       main = paste(\"COI = \", k)     )     abline(v = p_vec[which.max(new_y)], lty = 2)     text(       x = p_vec[which.max(new_y)] - 0.02, y = 0.0,       labels = p_vec[which.max(new_y)]     )   } }"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_coi_prediction.html","id":"method-2","dir":"Articles","previous_headings":"","what":"Method 2","title":"Example COI prediction","text":"method 2, plot WSAF PLAF sites heterogeneous, .e. REF ALT calls.  case, COI found 1/WSAF PLAF = 0 (.e. y-axis intercept).","code":"# loop over range of COIs disc_coi <- list() cont_coi <- list() par(mar = c(4, 4, 4, 4)) par(mfrow = c(3, 2)) for (k in 2:7) {    # simulate data and subset to heterozygous sites only   set.seed(10)   sim1 <- sim_biallelic(coi = k, plaf = p)    # plot raw WSAF as grey dots   plot(sim1$data$plaf, sim1$data$wsaf,     pch = 20, cex = 0.5, col = \"gray\",     ylim = c(0, 1), xlab = \"PLAF\", ylab = \"WSAF\", main = paste(\"COI =\", k)   )    # overlay analytical expectations for COI=2:7   p_vec <- seq(0, 0.5, l = 101)   theory_cois <- theoretical_coi(seq(1, 7), p_vec, coi_method = \"frequency\")   for (i in 2:7) {     lines(p_vec, theory_cois[[paste(\"coi_\", i, sep = \"\")]], col = 2, lwd = 2)   }   text(x = rep(-0.005, 6), y = 1 / 2:7, labels = 2:7, col = \"red\", cex = 0.6)    # compute sliding-window averages over WSAF and overlay in blue   df_grouped <- process_sim(sim1, coi_method = \"frequency\")   print(df_grouped$seq_error)    lines(df_grouped$data$midpoints, df_grouped$data$m_variant,     col = \"blue\", lwd = 2, type = \"o\", pch = 20   )    # Predict the COI and print the results   disc <- compute_coi(sim1, \"sim\", max_coi = 10, coi_method = \"frequency\")   disc_coi <- unlist(c(disc_coi, disc$coi))    # COI using optimization   cont <- optimize_coi(sim1, \"sim\", max_coi = 10, coi_method = \"frequency\")   cont_coi <- unlist(c(cont_coi, cont)) } #> [1] 0.01 #> [1] 0.05 #> [1] 0.063 #> [1] 0.157 #> [1] 0.225 #> [1] 0.1812"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_real_data.html","id":"data-structure","dir":"Articles","previous_headings":"","what":"Data structure","title":"Real data example","text":"Data fed algorithm matrix containing WSAF sample examined locus genome, sample represented rows locus represented columns. first 5 rows 3 columns example real data set included package shown :","code":"print(example_real_data[1:5, 1:3]) #>          Pf3D7_01_v3_94422 Pf3D7_01_v3_95518 Pf3D7_01_v3_100608 #> FP0024-C         0.8205128        0.43548387          0.4972067 #> FP0025-C         1.0000000        0.00000000          1.0000000 #> FP0028-C         0.7389381        0.48000000          1.0000000 #> FP0029-C         1.0000000        1.00000000          1.0000000 #> FP0030-C         0.6250000        0.01882353          1.0000000"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_real_data.html","id":"run-the-algorithm","dir":"Articles","previous_headings":"","what":"Run the algorithm","title":"Real data example","text":"Now data, running algorithm using either two methods quite straightforward. First, must compute PLAF average WSAF samples. dataset provided, example_real_data, 10 unique samples 1000 loci . Therefore, find COI sample, must generate loop iterate sample.","code":"plaf <- colMeans(example_real_data, na.rm = T)"},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_real_data.html","id":"discrete","dir":"Articles","previous_headings":"Run the algorithm > Method 1","what":"Discrete","title":"Real data example","text":"","code":"m1_dis <- lapply(seq_len(nrow(example_real_data)), function(i) {   # We first isolate the WSAF for that sample and then plug the WSAF and PLAF   # into our function   wsaf <- example_real_data[i, ]   input <- tibble::tibble(wsaf = wsaf, plaf = plaf) %>% tidyr::drop_na()   res <- compute_coi(input, \"real\", coi_method = \"variant\") })  # compute_coi returns both the COI and a measure of confidence in our prediction # thus we must isolate each separately m1_dis_cois <- lapply(m1_dis, function(x) {   x$coi }) %>% unlist()  # extract the probabilities and assign them names based on what COI was checked m1_dis_probs <- lapply(m1_dis, function(x) {   probs <- x$probability   names(probs) <- paste0(\"COI_\", 1:length(probs))   return(probs) })  # Assign the name of the sample to the returned vectors names(m1_dis_cois) <- rownames(example_real_data) names(m1_dis_probs) <- rownames(example_real_data)"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_real_data.html","id":"continuous","dir":"Articles","previous_headings":"Run the algorithm > Method 1","what":"Continuous","title":"Real data example","text":"","code":"m1_dis_cont <- lapply(seq_len(nrow(example_real_data)), function(i) {   # We first isolate the WSAF for that sample and then plug the WSAF and PLAF   # into our function   wsaf <- example_real_data[i, ]   input <- tibble::tibble(wsaf = wsaf, plaf = plaf) %>% tidyr::drop_na()   res <- optimize_coi(input, \"real\", coi_method = \"variant\") }) %>% unlist()  # Assign the name of the sample to the returned vector names(m1_dis_cont) <- rownames(example_real_data)"},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_real_data.html","id":"discrete-1","dir":"Articles","previous_headings":"Run the algorithm > Method 2","what":"Discrete","title":"Real data example","text":"","code":"m2_dis <- lapply(seq_len(nrow(example_real_data)), function(i) {   # We first isolate the WSAF for that sample and then plug the WSAF and PLAF   # into our function   wsaf <- example_real_data[i, ]   input <- tibble::tibble(wsaf = wsaf, plaf = plaf) %>% tidyr::drop_na()   res <- compute_coi(input, \"real\", coi_method = \"frequency\") })  # compute_coi returns both the COI and a measure of confidence in our prediction # thus we must isolate each separately m2_dis_cois <- lapply(m2_dis, function(x) {   x$coi }) %>% unlist()  # extract the probabilities and assign them names based on what COI was checked m2_dis_probs <- lapply(m2_dis, function(x) {   probs <- x$probability   names(probs) <- paste0(\"COI_\", 1:length(probs))   return(probs) })  # Assign the name of the sample to the returned vectors names(m2_dis_cois) <- rownames(example_real_data) names(m2_dis_probs) <- rownames(example_real_data)"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_real_data.html","id":"continuous-1","dir":"Articles","previous_headings":"Run the algorithm > Method 2","what":"Continuous","title":"Real data example","text":"","code":"m2_dis_cont <- lapply(seq_len(nrow(example_real_data)), function(i) {   # We first isolate the WSAF for that sample and then plug the WSAF and PLAF   # into our function   wsaf <- example_real_data[i, ]   input <- tibble::tibble(wsaf = wsaf, plaf = plaf) %>% tidyr::drop_na()   res <- optimize_coi(input, \"real\", coi_method = \"frequency\") }) %>% unlist()  # Assign the name of the sample to the returned vector names(m2_dis_cont) <- rownames(example_real_data)"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_real_data.html","id":"progress-bar","dir":"Articles","previous_headings":"","what":"Progress bar","title":"Real data example","text":"roughly 1000 loci 10 samples, model take less 0.5 seconds run. may helpful include progress bar running additional loci samples replacing lapply function user defined function. recommend use pbapply package, can used follows: left replace lapply newly defined list_apply.","code":"# Function to determine if pbapply is installed. If it is installed, it will # display a progress bar list_apply <- function(x, fun, ...) {   if (requireNamespace(\"pbapply\", quietly = TRUE)) {     pbapply::pblapply(x, fun, ...)   } else {     lapply(x, fun, ...)   } }"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_real_data.html","id":"data-visualization","dir":"Articles","previous_headings":"","what":"Data visualization","title":"Real data example","text":"recommend exploring ggplot2 package plot results. Graph Gallery beautiful website tons awesome graphs demos may provide inspiration.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_simulation.html","id":"theory","dir":"Articles","previous_headings":"","what":"Theory","title":"Simulation details","text":"package, synthetic sequencing data generated using simple statistical model number individuals given population. individual assigned COI value, used simulate number sequence reads mapped reference alternative allele biallelic SNPs considered. used derive within-sample frequency population-level minor allele, \\(w_i\\), locus. first define number loci simulated, \\(l\\). assume distribution reference allele frequencies locus \\(\\), \\(R_i\\), described Beta distribution shape parameters \\(\\alpha\\) \\(\\beta\\): \\[     \\mathbb{P}(R_i = r_i) = \\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha)\\Gamma(\\beta)}r_i^{(\\alpha-1)}(1-r_i)^{(\\beta-1)}, \\] \\(\\Gamma\\) Gamma function. simulations, assume \\(\\alpha = 1\\) \\(\\beta = 5\\) draw \\(l\\) values \\(R_i\\). methods, defined relationships respect frequency minor allele, \\(p_i\\). Recall \\(p_i \\[0, 0.5]\\). Thus, define \\[     p_i = \\begin{cases}           r_i & r_i \\leq 0.5 \\\\           1 - r_i & r_i > 0.5.        \\end{cases} \\] simulate \\(w_i\\) individual, first assign COI, \\(k\\). Next, simulate genotype locus \\(\\), drawing \\(k\\) values Binomial distribution probability \\(p_i\\), .e., probability minor allele locus \\(\\) equal population-level frequency minor allele. yields matrix, \\(\\mathbb{G} \\\\mathbb{R}^{k \\times l}\\), \\(k\\) rows \\(l\\) columns defining phased haplotype strain, \\(\\mathbb{G}_{,j} = 1\\) indicates strain \\(j\\) locus \\(\\) minor allele. determine number sequence reads related strain, first draw proportion strain, \\(\\mathbf{S} = (S_1, \\ldots, S_k)\\), individual \\(k\\) strains, assume described Dirichlet distribution concentration parameters \\(\\alpha_1, \\ldots, \\alpha_k\\). ``true” WSMAF minor allele locus \\(\\), denoted \\(\\tau_i\\), thus given sum strain proportions strains minor allele. can express using matrix multiplication: \\[     \\boldsymbol \\tau = \\mathbf{S} \\times \\mathbb{G}_i, \\] \\(\\boldsymbol \\tau \\\\mathbb{R}^{1 \\times l}\\), \\(\\mathbf{S} \\\\mathbb{R}^{1 \\times k}\\), \\(\\mathbb{G} \\\\mathbb{R}^{k \\times l}\\). simulations assumed sequence error, number sequence reads minor allele locus given sampling Binomial distribution \\(c\\) times probability \\(\\boldsymbol \\tau\\), \\(c\\) assumed number sequence reads, .e., read depth coverage. However, simulations sequence error, perturb ``true” WSMAF assuming number sequence reads incorrectly sampled. incorrectly sampled locus major allele yield minor allele vice versa. simulations, assume fixed sequence error, \\(\\epsilon\\), probability correctly sampling minor allele \\(1 - \\epsilon\\), probability incorrectly sampling minor allele \\(\\epsilon\\). Therefore, can represent probability sampling minor allele, now denoted \\(\\boldsymbol{\\tau}_\\epsilon\\) indicate added error, \\[     \\boldsymbol{\\tau}_\\epsilon = \\boldsymbol \\tau(1 - \\epsilon) + (1 - \\boldsymbol \\tau)\\epsilon. \\] Lastly, may account overdispersion—additional unexpected variability data—sample number sequence reads minor allele locus Beta-binomial distribution rather Binomial distribution. Dividing number instances minor allele coverage locus results simulated WSMAF.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/example_simulation.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Simulation details","text":"default values simulation run detailed table . PLMAF can generated follows Strain proportions can generated follows True WSMAF can found Simulated WSMAF can found ","code":"# Set the seed set.seed(1)  # Define number of loci, and the distribution of the minor allele frequencies L <- 5 plmaf <- rbeta(L, 1, 5) plmaf[plmaf > 0.5] <- 1 - plmaf[plmaf > 0.5]  tbl_plmaf <- t(plmaf) colnames(tbl_plmaf) <- paste(\"Locus\", 1:5)  knitr::kable(tbl_plmaf, digits = 3, align = \"l\") strain_p <- coiaf:::rdirichlet(rep(alpha, COI)) names(strain_p) <- paste(\"Strain\", 1:3)  knitr::kable(strain_p, digits = 3, col.names = \"Proportion\") true_wsmaf <- mapply(function(x) rbinom(COI, 1, x), x = plmaf) rownames(true_wsmaf) <- paste(\"Strain\", 1:3) colnames(true_wsmaf) <- paste(\"Locus\", 1:5)  knitr::kable(true_wsmaf, digits = 3) # Coverage L <- length(plmaf) if (length(coverage) == 1) {   coverage <- rep(coverage, L) }  p_levels <- colSums(sweep(true_wsmaf, 1, strain_p, \"*\"))  # Rounding errors from multiplying w by m can cause numbers greater than 1 p_levels[p_levels > 1] <- 1L  # Add in genotyping error p_error <- p_levels * (1 - epsilon) + (1 - p_levels) * epsilon  # Draw read counts, taking into account overdispersion if (overdispersion == 0) {   counts <- rbinom(L, size = coverage, prob = p_error) }  sim_wsmaf <- counts / coverage  tbl_sim_wsmaf <- t(sim_wsmaf) colnames(tbl_sim_wsmaf) <- paste(\"Locus\", 1:5) rownames(tbl_sim_wsmaf) <- \"WSMAF\"  knitr::kable(tbl_sim_wsmaf, digits = 3)"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Continuous sensitivity analysis","text":"analysis file, aim understand effect varying parameters COI framework. parameters examine : comparison: method employed. One \"end\", \"ideal\", \"overall\". distance: distance method used determine distance theoretical simulated curves \"overall\" method. One \"abs_sum\", \"sum_abs\", \"squared\". weighted: indicator indicating whether compute weighted distance. coverage: Coverage locus. loci: number loci. alpha: Shape parameter symmetric Dirichlet prior strain proportions. overdispersion: extent counts -dispersed relative binomial distribution. Counts Beta-binomially distributed, beta distribution shape parameters \\(p/\\text{overdispersion}\\) \\((1-p) / \\text{overdispersion}\\). epsilon: probability single read miscalled allele. Applies directions. seq_error: level sequencing error assumed. addition, compare two different methods determining COI. first method uses mean number variant sites, binned groups increasing PLAF infer COI. second method compares WSAF PLAF sites heterogeneous.","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"setting-our-plaf","dir":"Articles","previous_headings":"Introduction","what":"Setting our PLAF","title":"Continuous sensitivity analysis","text":"","code":"# Set the seed set.seed(1)  # Define number of loci, and distribution of minor allele frequencies L <- 1e3 p <- rbeta(L, 1, 5) p[p > 0.5] <- 1 - p[p > 0.5]"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"overall-performance","dir":"Articles","previous_headings":"Introduction","what":"Overall performance","title":"Continuous sensitivity analysis","text":"","code":"toverall <- cont_sensitivity(   coi = 1:20,   repetitions = 100,   plaf = p,   coverage = 400,   seq_error = 0,   coi_method = c(\"variant\", \"frequency\") )  toverall_image <- sensitivity_plot(   data = toverall,   dims = c(1, 2),   result_type = \"cont\",   title = \"Predicted COI\",   sub_title = c(\"Variant Method\", \"Frequency Method\") )  toverall_error <- error_plot(   toverall,   fill = \"coi_method\",   legend_title = \"COI Method\",   title = \"Error\",   fill_levels = c(\"Variant Method\", \"Frequency Method\") )  toverall_fig <- toverall_image / toverall_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   ggplot2::theme(legend.position = \"bottom\")  toverall_fig"},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"coi","dir":"Articles","previous_headings":"Sensitivity analysis","what":"COI","title":"Continuous sensitivity analysis","text":"","code":"tcoi <- cont_sensitivity(   coi = 2:40,   max_coi = 40,   repetitions = 100,   plaf = p,   seq_error = 0.01,   coi_method = c(\"variant\", \"frequency\") )  tcoi_image <- sensitivity_plot(   data = tcoi,   dims = c(1, 2),   result_type = \"cont\",   title = \"Predicted COI\",   sub_title = c(\"Variant Method\", \"Frequency Method\") )  tcoi_error <- error_plot(   tcoi,   fill = \"coi_method\",   legend_title = \"COI Method\",   title = \"Error\",   fill_levels = c(\"Variant Method\", \"Frequency Method\") )  tcoi_fig <- tcoi_image / tcoi_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   ggplot2::theme(legend.position = \"bottom\")  tcoi_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"comparison","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Comparison","title":"Continuous sensitivity analysis","text":"","code":"tcomparison <- cont_sensitivity(   coi = 2:20,   plaf = p,   comparison = c(\"end\", \"ideal\", \"overall\"),   distance = \"squared\",   repetitions = 100,   seq_error = 0.01 )  tcomparison_image <- sensitivity_plot(   data = tcomparison,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(1, 3),   sub_title = paste0(\"Comparison = \", c(\"End\", \"Ideal\", \"Overall\")) )  tcomparison_error <- error_plot(   tcomparison,   fill = \"comparison\",   legend_title = \"Method\",   fill_levels = c(\"End\", \"Ideal\", \"Overall\"),   title = \"Error\" )  tcomparison_fig <- tcomparison_image / tcomparison_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   ggplot2::theme(legend.position = \"bottom\")  tcomparison_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"distance","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Distance","title":"Continuous sensitivity analysis","text":"","code":"tdistance <- cont_sensitivity(   coi = 2:20,   plaf = p,   comparison = \"overall\",   distance = c(\"abs_sum\", \"sum_abs\", \"squared\"),   repetitions = 100,   seq_error = 0.01,   coi_method = c(\"variant\", \"frequency\") )  tdistance_image <- sensitivity_plot(   data = tdistance,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(3, 2),   sub_title = paste(     rep(c(\"Absolute Sum\", \"Sum of Absolute\", \"Squared Error\"), 2),     rep(c(\"Variant Method\", \"Frequency Method\"), each = 3),     sep = \", \"   ) )  tdistance_error <- error_plot(   tdistance,   fill = \"distance\",   legend_title = \"Distance Method\",   fill_levels = c(\"Absolute Sum\", \"Squared Error\", \"Sum of Absolute\"),   title = \"Error\",   second_fill = \"coi_method\" )  tdistance_fig <- tdistance_image / tdistance_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(3, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tdistance_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"coverage","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Coverage","title":"Continuous sensitivity analysis","text":"","code":"tcoverage_1 <- cont_sensitivity(   coi = 2:20,   coverage = c(50, 100, 250, 500, 1000, 2000),   repetitions = 100,   seq_error = 0.01,   plaf = p,   coi_method = \"variant\" )  tcoverage_image_1 <- sensitivity_plot(   data = tcoverage_1,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(2, 3),   sub_title = paste0(\"Coverage = \", c(50, 100, 250, 500, 1000, 2000)) )  tcoverage_error_1 <- error_plot(   tcoverage_1,   fill = \"coverage\",   legend_title = \"Coverage\",   title = \"Error\" )  tcoverage_fig_1 <- tcoverage_image_1 / tcoverage_error_1 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(2, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tcoverage_fig_1 tcoverage_2 <- cont_sensitivity(   coi = 2:20,   coverage = c(50, 100, 250, 500, 1000, 2000),   repetitions = 100,   seq_error = 0.01,   plaf = p, coi_method = \"frequency\" )  tcoverage_image_2 <- sensitivity_plot(   data = tcoverage_2,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(2, 3),   sub_title = paste0(\"Coverage = \", c(50, 100, 250, 500, 1000, 2000)) )  tcoverage_error_2 <- error_plot(   tcoverage_2,   fill = \"coverage\",   legend_title = \"Coverage\",   title = \"Error\" )  tcoverage_fig_2 <- tcoverage_image_2 / tcoverage_error_2 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(2, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tcoverage_fig_2"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"loci","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Loci","title":"Continuous sensitivity analysis","text":"","code":"# Set the range over which we will iterate loci <- c(1e2, 1e3, 1e4)  # For each loci, reset the PLAF and then run bloci <- lapply(loci, function(new_L) {   new_p <- rbeta(new_L, 1, 5)   new_p[new_p > 0.5] <- 1 - new_p[new_p > 0.5]    inner_tloci <- cont_sensitivity(     coi = 2:20,     repetitions = 100,     plaf = new_p,     seq_error = 0.01,     coi_method = \"variant\"   )   inner_tloci$param_grid$loci <- new_L   return(inner_tloci) })  # Extract the relevant information for each output: predicted_coi, probability, # param_grid, and boot_error pc <- do.call(cbind, lapply(bloci, function(test) {   return(test$predicted_coi) })) pb <- do.call(cbind, lapply(bloci, function(test) {   return(test$probability) })) pg <- do.call(rbind, lapply(bloci, function(test) {   return(test$param_grid) })) be <- do.call(rbind, lapply(bloci, function(test) {   return(test$boot_error) }))  # Fix the naming for predicted_coi num_cois <- length(unique(pg$coi)) num_repeat_cois <- length(pg$coi) / num_cois names(pc) <- paste(   \"coi\",   pg$coi,   rep(seq(num_repeat_cois), each = num_cois),   sep = \"_\" )  # Create the output tloci_1 <- list(   predicted_coi = pc,   probability   = pb,   param_grid    = pg,   boot_error    = be )  # Plot tloci_image_1 <- sensitivity_plot(   data = tloci_1,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(1, 3),   sub_title = paste0(\"Loci = \", c(1e2, 1e3, 1e4)) )  # Add a loci column tloci_1$boot_error$loci <- rep(   c(1e2, 1e3, 1e4),   each = length(unique(tloci_1$boot_error$coi)) ) tloci_error_1 <- error_plot(   tloci_1,   fill = \"loci\",   legend_title = \"Loci\",   title = \"Error\" )  tloci_fig_1 <- tloci_image_1 / tloci_error_1 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   ggplot2::theme(legend.position = \"bottom\")  tloci_fig_1 # Set the range over which we will iterate loci <- c(1e2, 1e3, 1e4)  # For each loci, reset the PLAF and then run bloci <- lapply(loci, function(new_L) {   new_p <- rbeta(new_L, 1, 5)   new_p[new_p > 0.5] <- 1 - new_p[new_p > 0.5]    inner_tloci <- cont_sensitivity(     coi = 2:20,     repetitions = 100,     plaf = new_p,     seq_error = 0.01,     coi_method = \"frequency\"   )   inner_tloci$param_grid$loci <- new_L   return(inner_tloci) })  # Extract the relevant information for each output: predicted_coi, probability, # param_grid, and boot_error pc <- do.call(cbind, lapply(bloci, function(test) {   return(test$predicted_coi) })) pb <- do.call(cbind, lapply(bloci, function(test) {   return(test$probability) })) pg <- do.call(rbind, lapply(bloci, function(test) {   return(test$param_grid) })) be <- do.call(rbind, lapply(bloci, function(test) {   return(test$boot_error) }))  # Fix the naming for predicted_coi num_cois <- length(unique(pg$coi)) num_repeat_cois <- length(pg$coi) / num_cois names(pc) <- paste(   \"coi\",   pg$coi,   rep(seq(num_repeat_cois), each = num_cois),   sep = \"_\" )  # Create the output tloci_2 <- list(   predicted_coi = pc,   probability   = pb,   param_grid    = pg,   boot_error    = be )  # Plot tloci_image_2 <- sensitivity_plot(   data = tloci_2,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(1, 3),   sub_title = paste0(\"Loci = \", c(1e2, 1e3, 1e4)) )  # Add a loci column tloci_2$boot_error$loci <- rep(   c(1e2, 1e3, 1e4),   each = length(unique(tloci_2$boot_error$coi)) ) tloci_error_2 <- error_plot(   tloci_2,   fill = \"loci\",   legend_title = \"Loci\",   title = \"Error\" )  tloci_fig_2 <- tloci_image_2 / tloci_error_2 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   ggplot2::theme(legend.position = \"bottom\")  tloci_fig_2"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"alpha","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Alpha","title":"Continuous sensitivity analysis","text":"","code":"talpha_1 <- cont_sensitivity(   coi = 2:20,   alpha = seq(0.01, 5.51, 0.5),   repetitions = 100,   seq_error = 0.01,   plaf = p )  talpha_image_1 <- sensitivity_plot(   data = talpha_1,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(4, 3),   sub_title = paste0(\"Alpha = \", seq(0.01, 5.51, 0.5)) )  talpha_error_1 <- error_plot(   talpha_1,   fill = \"alpha\",   legend_title = \"Alpha\",   title = \"Error\" )  talpha_fig_1 <- talpha_image_1 / talpha_error_1 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(5, 1)) +   ggplot2::theme(legend.position = \"bottom\")  talpha_fig_1 talpha_2 <- cont_sensitivity(   coi = 2:20,   alpha = seq(0.01, 5.51, 0.5),   repetitions = 100,   seq_error = 0.01,   plaf = p )  talpha_image_2 <- sensitivity_plot(   data = talpha_2,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(4, 3),   sub_title = paste0(\"Alpha = \", seq(0.01, 5.51, 0.5)) )  talpha_error_2 <- error_plot(   talpha_2,   fill = \"alpha\",   legend_title = \"Alpha\",   title = \"Error\" )  talpha_fig_2 <- talpha_image_2 / talpha_error_2 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(5, 1)) +   ggplot2::theme(legend.position = \"bottom\")  talpha_fig_2"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"overdispersion","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Overdispersion","title":"Continuous sensitivity analysis","text":"","code":"tover <- cont_sensitivity(   coi = 2:20,   overdispersion = seq(0, 0.2, 0.05),   repetitions = 100,   seq_error = 0.01,   plaf = p,   coi_method = c(\"variant\", \"frequency\") )  tover_image <- sensitivity_plot(   data = tover,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(4, 3),   sub_title = paste(     paste0(\"Over \", seq(0, 0.2, 0.05)),     rep(c(\"Variant Method\", \"Frequency Method\"), each = 5),     sep = \", \"   ) )  tover_error <- error_plot(   tover,   fill = \"overdispersion\",   legend_title = \"Overdispersion\",   title = \"Error\",   second_fill = \"coi_method\" )  tover_fig <- tover_image / tover_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(5, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tover_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"relatedness","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Relatedness","title":"Continuous sensitivity analysis","text":"","code":"trelated <- cont_sensitivity(   coi = 2:20,   relatedness = seq(0, 0.5, 0.1),   repetitions = 100,   seq_error = 0.01,   plaf = p,   coi_method = c(\"variant\", \"frequency\") )  trelated_image <- sensitivity_plot(   data = trelated,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(4, 3),   sub_title = paste(     paste0(\"Related =  \", seq(0, 0.5, 0.1)),     rep(c(\"Variant Method\", \"Frequency Method\"), each = 6),     sep = \", \"   ) )  trelated_error <- error_plot(   trelated,   fill = \"relatedness\",   legend_title = \"Related\",   title = \"Error\",   second_fill = \"coi_method\" )  trelated_fig <- trelated_image / trelated_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(6, 1)) +   ggplot2::theme(legend.position = \"bottom\")  trelated_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"epsilon","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Epsilon","title":"Continuous sensitivity analysis","text":"","code":"tepsilon <- cont_sensitivity(   coi = 2:20,   epsilon = seq(0, 0.025, 0.005),   repetitions = 100,   seq_error = 0.01,   plaf = p )  tepsilon_image <- sensitivity_plot(   data = tepsilon,   result_type = \"cont\",   title = \"Predicted COI\",   sub_title = paste0(\"Epsilon = \", seq(0, 0.025, 0.005)),   dims = c(2, 3) )  tepsilon_error <- error_plot(   tepsilon,   fill = \"epsilon\",   legend_title = \"Epsilon\",   title = \"Error\" )  tepsilon_fig <- tepsilon_image / tepsilon_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(3, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tepsilon_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"sequencing-error","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Sequencing error","title":"Continuous sensitivity analysis","text":"","code":"tseq <- cont_sensitivity(   coi = 2:20,   epsilon = 0.01,   seq_error = seq(0, 0.10, 0.02),   repetitions = 100,   plaf = p,   coi_method = \"frequency\" )  tseq_image <- sensitivity_plot(   data = tseq,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(2, 3),   sub_title = paste0(\"Sequence Error = \", seq(0, 0.12, 0.02)) )  tseq_error <- error_plot(   tseq,   fill = \"seq_error\",   legend_title = \"Sequence Error\",   title = \"Error\" )  tseq_fig <- tseq_image / tseq_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(2, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tseq_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_continuous.html","id":"bin-size","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Bin size","title":"Continuous sensitivity analysis","text":"","code":"tbin <- cont_sensitivity(   coi = 2:20,   bin_size = seq(10, 100, 30),   distance = \"squared\",   plaf = p,   repetitions = 100,   seq_error = 0.01,   coi_method = c(\"variant\", \"frequency\") )  tbin_image <- sensitivity_plot(   data = tbin,   result_type = \"cont\",   title = \"Predicted COI\",   dims = c(2, 4),   sub_title = rep(paste(\"Bin Size =\", seq(10, 100, 30)), 2) )  tbin_error <- error_plot(   tbin,   fill = \"bin_size\",   fill_levels = c(\"10\", \"40\", \"70\", \"100\"),   legend_title = \"COI Method\",   title = \"Error\" )  tbin_fig <- tbin_image / tbin_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(3, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tbin_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Discrete sensitivity analysis","text":"analysis file, aim understand effect varying parameters COI framework. parameters examine : comparison: method employed. One \"end\", \"ideal\", \"overall\". distance: distance method used determine distance theoretical simulated curves \"overall\" method. One \"abs_sum\", \"sum_abs\", \"squared\". coverage: Coverage locus. loci: number loci. alpha: Shape parameter symmetric Dirichlet prior strain proportions. overdispersion: extent counts -dispersed relative binomial distribution. Counts Beta-binomially distributed, beta distribution shape parameters \\(p/\\text{overdispersion}\\) \\((1-p) / \\text{overdispersion}\\). epsilon: probability single read miscalled allele. Applies directions. seq_error: level sequencing error assumed. bin_size: minimum size bin data. addition, compare two different methods determining COI. first method uses mean number variant sites, binned groups increasing PLAF infer COI. second method compares WSAF PLAF sites heterogeneous.","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"setting-our-plaf","dir":"Articles","previous_headings":"Introduction","what":"Setting our PLAF","title":"Discrete sensitivity analysis","text":"","code":"# Set the seed set.seed(1)  # Define number of loci, and distribution of minor allele frequencies L <- 1e3 p <- stats::rbeta(L, 1, 5) p[p > 0.5] <- 1 - p[p > 0.5]"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"overall-performance","dir":"Articles","previous_headings":"Introduction","what":"Overall performance","title":"Discrete sensitivity analysis","text":"","code":"toverall <- sensitivity(   coi = 1:20,   repetitions = 100,   plaf = p,   coverage = 1000,   seq_error = 0,   coi_method = c(\"variant\", \"frequency\") )  toverall_image <- sensitivity_plot(   data = toverall,   dims = c(1, 2),   result_type = \"disc\",   title = \"Predicted COI\",   sub_title = c(\"Variant Method\", \"Frequency Method\") )  toverall_error <- error_plot(   data = toverall,   fill = \"coi_method\",   legend_title = \"COI Method\",   title = \"Error\",   fill_levels = c(\"Variant Method\", \"Frequency Method\") )  toverall_fig <- toverall_image / toverall_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   ggplot2::theme(legend.position = \"bottom\")  toverall_fig"},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"coi","dir":"Articles","previous_headings":"Sensitivity analysis","what":"COI","title":"Discrete sensitivity analysis","text":"","code":"tcoi <- sensitivity(   coi = 2:40,   max_coi = 40,   repetitions = 100,   plaf = p,   seq_error = 0.01,   coi_method = c(\"variant\", \"frequency\") )  tcoi_image <- sensitivity_plot(   data = tcoi,   dims = c(1, 2),   result_type = \"disc\",   title = \"Predicted COI\",   sub_title = c(\"Variant Method\", \"Frequency Method\") )  tcoi_error <- error_plot(   tcoi,   fill = \"coi_method\",   legend_title = \"COI Method\",   title = \"Error\",   fill_levels = c(\"Variant Method\", \"Frequency Method\") )  tcoi_fig <- tcoi_image / tcoi_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   ggplot2::theme(legend.position = \"bottom\")  tcoi_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"comparison","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Comparison","title":"Discrete sensitivity analysis","text":"","code":"tcomparison <- sensitivity(   coi = 2:20,   plaf = p,   comparison = c(\"end\", \"ideal\", \"overall\"),   distance = \"squared\",   repetitions = 100,   seq_error = 0.01 )  tcomparison_image <- sensitivity_plot(   data = tcomparison,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(1, 3),   sub_title = paste0(\"Comparison = \", c(\"End\", \"Ideal\", \"Overall\")) )  tcomparison_error <- error_plot(tcomparison,   fill = \"comparison\",   legend_title = \"Method\",   fill_levels = c(\"End\", \"Ideal\", \"Overall\"),   title = \"Error\" )  tcomparison_fig <- tcomparison_image / tcomparison_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   ggplot2::theme(legend.position = \"bottom\")  tcomparison_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"distance","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Distance","title":"Discrete sensitivity analysis","text":"","code":"tdistance <- sensitivity(   coi = 2:20,   plaf = p,   comparison = \"overall\",   distance = c(\"abs_sum\", \"sum_abs\", \"squared\"),   repetitions = 100,   seq_error = 0.01,   coi_method = c(\"variant\", \"frequency\") )  tdistance_image <- sensitivity_plot(   data = tdistance,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(3, 2),   sub_title = paste(     rep(c(\"Absolute Sum\", \"Sum of Absolute\", \"Squared Error\"), 2),     rep(c(\"Variant Method\", \"Frequency Method\"), each = 3),     sep = \", \"   ) )  tdistance_error <- error_plot(   tdistance,   fill = \"distance\",   legend_title = \"Distance Method\",   fill_levels = c(\"Absolute Sum\", \"Squared Error\", \"Sum of Absolute\"),   title = \"Error\",   second_fill = \"coi_method\" )  tdistance_fig <- tdistance_image / tdistance_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(3, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tdistance_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"coverage","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Coverage","title":"Discrete sensitivity analysis","text":"","code":"tcoverage_1 <- sensitivity(   coi = 2:20,   coverage = c(50, 100, 250, 500, 1000, 2000),   repetitions = 100,   seq_error = 0.01,   plaf = p,   coi_method = \"variant\" )  tcoverage_image_1 <- sensitivity_plot(   data = tcoverage_1,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(2, 3),   sub_title = paste0(\"Coverage = \", c(50, 100, 250, 500, 1000, 2000)) )  tcoverage_error_1 <- error_plot(   tcoverage_1,   fill = \"coverage\",   legend_title = \"Coverage\",   title = \"Error\" )  tcoverage_fig_1 <- tcoverage_image_1 / tcoverage_error_1 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(2, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tcoverage_fig_1 tcoverage_2 <- sensitivity(   coi = 2:20,   coverage = c(50, 100, 250, 500, 1000, 2000),   repetitions = 100,   seq_error = 0.01,   plaf = p, coi_method = \"frequency\" )  tcoverage_image_2 <- sensitivity_plot(   data = tcoverage_2,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(2, 3),   sub_title = paste0(\"Coverage = \", c(50, 100, 250, 500, 1000, 2000)) )  tcoverage_error_2 <- error_plot(   tcoverage_2,   fill = \"coverage\",   legend_title = \"Coverage\",   title = \"Error\" )  tcoverage_fig_2 <- tcoverage_image_2 / tcoverage_error_2 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(2, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tcoverage_fig_2"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"loci","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Loci","title":"Discrete sensitivity analysis","text":"","code":"# Set the range over which we will iterate loci <- c(1e2, 1e3, 1e4)  # For each loci, reset the PLAF and then run bloci <- lapply(loci, function(new_L) {   new_p <- rbeta(new_L, 1, 5)   new_p[new_p > 0.5] <- 1 - new_p[new_p > 0.5]    inner_tloci <- sensitivity(     coi = 2:20,     repetitions = 100,     plaf = new_p,     seq_error = 0.01,     coi_method = \"variant\"   )   inner_tloci$param_grid$loci <- new_L   return(inner_tloci) })  # Extract the relevant information for each output: predicted_coi, probability, # param_grid, and boot_error pc <- do.call(cbind, lapply(bloci, function(test) {   return(test$predicted_coi) })) pb <- do.call(cbind, lapply(bloci, function(test) {   return(test$probability) })) pg <- do.call(rbind, lapply(bloci, function(test) {   return(test$param_grid) })) be <- do.call(rbind, lapply(bloci, function(test) {   return(test$boot_error) }))  # Fix the naming for predicted_coi num_cois <- length(unique(pg$coi)) num_repeat_cois <- length(pg$coi) / num_cois names(pc) <- paste(   \"coi\",   pg$coi,   rep(seq(num_repeat_cois), each = num_cois),   sep = \"_\" )  # Create the output tloci_1 <- list(   predicted_coi = pc,   probability   = pb,   param_grid    = pg,   boot_error    = be )  # Plot tloci_image_1 <- sensitivity_plot(   data = tloci_1,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(1, 3),   sub_title = paste0(\"Loci = \", c(1e2, 1e3, 1e4)) )  # Add a loci column tloci_1$boot_error$loci <- rep(   c(1e2, 1e3, 1e4),   each = length(unique(tloci_1$boot_error$coi)) ) tloci_error_1 <- error_plot(   tloci_1,   fill = \"loci\",   legend_title = \"Loci\",   title = \"Error\" )  tloci_fig_1 <- tloci_image_1 / tloci_error_1 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   ggplot2::theme(legend.position = \"bottom\")  tloci_fig_1 # Set the range over which we will iterate loci <- c(1e2, 1e3, 1e4)  # For each loci, reset the PLAF and then run bloci <- lapply(loci, function(new_L) {   new_p <- rbeta(new_L, 1, 5)   new_p[new_p > 0.5] <- 1 - new_p[new_p > 0.5]    inner_tloci <- sensitivity(     coi = 2:20,     repetitions = 100,     plaf = new_p,     seq_error = 0.01,     coi_method = \"frequency\"   )   inner_tloci$param_grid$loci <- new_L   return(inner_tloci) })  # Extract the relevant information for each output: predicted_coi, probability, # param_grid, and boot_error pc <- do.call(cbind, lapply(bloci, function(test) {   return(test$predicted_coi) })) pb <- do.call(cbind, lapply(bloci, function(test) {   return(test$probability) })) pg <- do.call(rbind, lapply(bloci, function(test) {   return(test$param_grid) })) be <- do.call(rbind, lapply(bloci, function(test) {   return(test$boot_error) }))  # Fix the naming for predicted_coi num_cois <- length(unique(pg$coi)) num_repeat_cois <- length(pg$coi) / num_cois names(pc) <- paste(   \"coi\",   pg$coi,   rep(seq(num_repeat_cois), each = num_cois),   sep = \"_\" )  # Create the output tloci_2 <- list(   predicted_coi = pc,   probability   = pb,   param_grid    = pg,   boot_error    = be )  # Plot tloci_image_2 <- sensitivity_plot(   data = tloci_2,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(1, 3),   sub_title = paste0(\"Loci = \", c(1e2, 1e3, 1e4)) )  # Add a loci column tloci_2$boot_error$loci <- rep(   c(1e2, 1e3, 1e4),   each = length(unique(tloci_2$boot_error$coi)) ) tloci_error_2 <- error_plot(   tloci_2,   fill = \"loci\",   legend_title = \"Loci\",   title = \"Error\" )  tloci_fig_2 <- tloci_image_2 / tloci_error_2 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   ggplot2::theme(legend.position = \"bottom\")  tloci_fig_2"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"alpha","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Alpha","title":"Discrete sensitivity analysis","text":"","code":"talpha_1 <- sensitivity(   coi = 2:20,   alpha = seq(0.01, 5.51, 0.5),   repetitions = 100,   seq_error = 0.01,   plaf = p )  talpha_image_1 <- sensitivity_plot(   data = talpha_1,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(4, 3),   sub_title = paste0(\"Alpha = \", seq(0.01, 5.51, 0.5)) )  talpha_error_1 <- error_plot(   talpha_1,   fill = \"alpha\",   legend_title = \"Alpha\",   title = \"Error\" )  talpha_fig_1 <- talpha_image_1 / talpha_error_1 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(5, 1)) +   ggplot2::theme(legend.position = \"bottom\")  talpha_fig_1 talpha_2 <- sensitivity(   coi = 2:20,   alpha = seq(0.01, 5.51, 0.5),   repetitions = 100,   seq_error = 0.01,   plaf = p )  talpha_image_2 <- sensitivity_plot(   data = talpha_2,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(4, 3),   sub_title = paste0(\"Alpha = \", seq(0.01, 5.51, 0.5)) )  talpha_error_2 <- error_plot(   talpha_2,   fill = \"alpha\",   legend_title = \"Alpha\",   title = \"Error\" )  talpha_fig_2 <- talpha_image_2 / talpha_error_2 +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(5, 1)) +   ggplot2::theme(legend.position = \"bottom\")  talpha_fig_2"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"overdispersion","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Overdispersion","title":"Discrete sensitivity analysis","text":"","code":"tover <- sensitivity(   coi = 2:20,   overdispersion = seq(0, 0.2, 0.05),   repetitions = 100,   seq_error = 0.01,   plaf = p,   coi_method = c(\"variant\", \"frequency\") )  tover_image <- sensitivity_plot(   data = tover,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(4, 3),   sub_title = paste(     paste0(\"Dispersion = \", seq(0, 0.2, 0.05)),     rep(c(\"Variant\", \"Frequency\"), each = 5),     sep = \", \"   ) )  tover_error <- error_plot(   tover,   fill = \"overdispersion\",   legend_title = \"Overdispersion\",   title = \"Error\",   second_fill = \"coi_method\" )  tover_fig <- tover_image / tover_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(5, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tover_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"relatedness","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Relatedness","title":"Discrete sensitivity analysis","text":"","code":"trelated <- sensitivity(   coi = 2:20,   relatedness = seq(0, 0.5, 0.1),   repetitions = 100,   seq_error = 0.01,   plaf = p,   coi_method = c(\"variant\", \"frequency\") )  trelated_image <- sensitivity_plot(   data = trelated,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(4, 3),   sub_title = paste(     paste0(\"Relatedness =  \", seq(0, 0.5, 0.1)),     rep(c(\"Variant\", \"Frequency\"), each = 6),     sep = \", \"   ) )  trelated_error <- error_plot(   trelated,   fill = \"relatedness\",   legend_title = \"Related\",   title = \"Error\",   second_fill = \"coi_method\" )  trelated_fig <- trelated_image / trelated_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(6, 1)) +   ggplot2::theme(legend.position = \"bottom\")  trelated_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"epsilon","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Epsilon","title":"Discrete sensitivity analysis","text":"","code":"tepsilon <- sensitivity(   coi = 2:20,   epsilon = seq(0, 0.025, 0.005),   repetitions = 100,   seq_error = 0.01,   plaf = p )  tepsilon_image <- sensitivity_plot(   data = tepsilon,   result_type = \"disc\",   title = \"Predicted COI\",   sub_title = paste0(\"Epsilon = \", seq(0, 0.025, 0.005)),   dims = c(2, 3) )  tepsilon_error <- error_plot(   tepsilon,   fill = \"epsilon\",   legend_title = \"Epsilon\",   title = \"Error\" )  tepsilon_fig <- tepsilon_image / tepsilon_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(3, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tepsilon_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"sequencing-error","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Sequencing error","title":"Discrete sensitivity analysis","text":"","code":"tseq <- sensitivity(   coi = 2:20,   epsilon = 0.01,   seq_error = seq(0, 0.10, 0.02),   repetitions = 100,   plaf = p,   coi_method = \"frequency\" )  tseq_image <- sensitivity_plot(   data = tseq,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(2, 3),   sub_title = paste0(\"Sequence Error = \", seq(0, 0.12, 0.02)) )  tseq_error <- error_plot(   tseq,   fill = \"seq_error\",   legend_title = \"Sequence Error\",   title = \"Error\" )  tseq_fig <- tseq_image / tseq_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(2, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tseq_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/articles/sensitivity_analysis_discrete.html","id":"bin-size","dir":"Articles","previous_headings":"Sensitivity analysis","what":"Bin size","title":"Discrete sensitivity analysis","text":"","code":"tbin <- sensitivity(   coi = 2:20,   bin_size = seq(10, 100, 30),   distance = \"squared\",   plaf = p,   repetitions = 100,   seq_error = 0.01,   coi_method = c(\"variant\", \"frequency\") )  tbin_image <- sensitivity_plot(   data = tbin,   result_type = \"disc\",   title = \"Predicted COI\",   dims = c(2, 4),   sub_title = rep(paste(\"Bin Size =\", seq(10, 100, 30)), 2) )  tbin_error <- error_plot(   tbin,   fill = \"bin_size\",   fill_levels = c(\"10\", \"40\", \"70\", \"100\"),   legend_title = \"COI Method\",   title = \"Error\" )  tbin_fig <- tbin_image / tbin_error +   patchwork::plot_annotation(     tag_levels = \"A\",     theme = ggplot2::theme(plot.tag = ggplot2::element_text(size = 10))   ) +   patchwork::plot_layout(heights = c(3, 1)) +   ggplot2::theme(legend.position = \"bottom\")  tbin_fig"},{"path":"https://bailey-lab.github.io/coiaf/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aris Paschalidis. Author, maintainer. OJ Watson. Author.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Paschalidis , Watson O (2022). coiaf: Complexity Infection Estimation Allele Frequencies. https://bailey-lab.github.io/coiaf/, https://github.com/bailey-lab/coiaf.","code":"@Manual{,   title = {coiaf: Complexity of Infection Estimation with Allele Frequencies},   author = {Aris Paschalidis and OJ Watson},   year = {2022},   note = {https://bailey-lab.github.io/coiaf/, https://github.com/bailey-lab/coiaf}, }"},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Complexity of Infection Estimation with Allele Frequencies","text":"malaria, individuals often infected different parasite strains, complexity infection (COI) giving number genetically different parasite strains individual. Changes mean COI population shown informative changes transmission intensity number probabilistic likelihood Bayesian models now developed estimate COI. However, rapid, direct measures based heterozygosity FwS directly related COI. package present two new methods use easily calculated measures directly estimate COI sequence read depth data.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Complexity of Infection Estimation with Allele Frequencies","text":"","code":"# Install development version devtools::install_github(\"bailey-lab/coiaf\")"},{"path":"https://bailey-lab.github.io/coiaf/dev/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Complexity of Infection Estimation with Allele Frequencies","text":"Please consult example real data vignette primer run real data using coiaf. description estimation methods work, please consult example coi prediction vignette.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/index.html","id":"development","dir":"","previous_headings":"Usage","what":"Development","title":"Complexity of Infection Estimation with Allele Frequencies","text":"Please note package still development may missing features.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/coiaf-package.html","id":null,"dir":"Reference","previous_headings":"","what":"coiaf: Complexity of Infection Estimation with Allele Frequencies — coiaf-package","title":"coiaf: Complexity of Infection Estimation with Allele Frequencies — coiaf-package","text":"Provides direct method estimating complexity infection using easily calculated measures sequence read depth data.","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/coiaf-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"coiaf: Complexity of Infection Estimation with Allele Frequencies — coiaf-package","text":"Maintainer: Aris Paschalidis aris_paschalidis@brown.edu (ORCID) Authors: OJ Watson oj.watson@hotmail.co.uk (ORCID)","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/compute_coi.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict the COI — compute_coi","title":"Predict the COI — compute_coi","text":"Predict COI sample.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/compute_coi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict the COI — compute_coi","text":"","code":"compute_coi(   data,   data_type,   max_coi = 25,   seq_error = NULL,   bin_size = 20,   comparison = \"overall\",   distance = \"squared\",   coi_method = \"variant\" )"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/compute_coi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict the COI — compute_coi","text":"data data COI computed. data_type type data analyzed. One \"sim\" \"real\". max_coi number indicating maximum COI compare simulated data . seq_error level sequencing error assumed. value inputted, infer level sequence error. bin_size minimum size bin data. comparison method employed. One \"end\", \"ideal\", \"overall\". distance distance method used determine distance theoretical simulated curves \"overall\" method. One \"abs_sum\", \"sum_abs\", \"squared\". coi_method method use calculate theoretical COI. method either \"variant\" \"frequency\". default value \"variant\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/compute_coi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict the COI — compute_coi","text":"list following: coi: predicted COI sample. probability: probability density function representing probability COI.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/compute_coi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict the COI — compute_coi","text":"Compare within sample allele frequency (WSAF) population level allele frequency (PLAF) sample theoretical WSAF PLAF look like. examining sample's WSAF PLAF theoretical WSAF PLAF, estimation can made COI sample . refer sample's WSAF vs PLAF \"sample curve\" refer theoretical WSAF vs PLAF \"theoretical curve.\" determine predicted COI value, one three different methods can selected: end Determines distance theoretical sample curve PLAF 0.5. COI whichever theoretical COI curve smallest distance simulated data. ideal Determines distance theoretical sample curve ideal PLAF. ideal PLAF calculated looking change COI \\(\\) COI \\(-1\\) finding PLAF distance maximized. COI whichever theoretical COI curve smallest distance simulated data ideal PLAF. overall Determines distance theoretical simulated curve PLAFs. Computes distance theoretical curves simulated curve. COI whichever theoretical curve smallest distance simulated curve. option choose one several distance metrics: abs_sum: Absolute value sum difference. sum_abs: Sum absolute difference. squared: Sum squared difference.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/cont_sensitivity.html","id":null,"dir":"Reference","previous_headings":"","what":"Continuous sensitivity analysis — cont_sensitivity","title":"Continuous sensitivity analysis — cont_sensitivity","text":"Runs several iterations full COI sensitivity analysis varying parameters.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/cont_sensitivity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Continuous sensitivity analysis — cont_sensitivity","text":"","code":"cont_sensitivity(   repetitions = 10,   coi = 3,   max_coi = 25,   plaf = runif(1000, 0, 0.5),   coverage = 200,   alpha = 1,   overdispersion = 0,   relatedness = 0,   epsilon = 0,   seq_error = NULL,   bin_size = 20,   comparison = \"overall\",   distance = \"squared\",   coi_method = \"variant\" )"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/cont_sensitivity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Continuous sensitivity analysis — cont_sensitivity","text":"repetitions number times sample run. coi Complexity infection. max_coi number indicating maximum COI compare simulated data . plaf Vector population-level allele frequencies locus. coverage Coverage locus. single value coverage applied loci. alpha Shape parameter symmetric Dirichlet prior strain proportions. overdispersion extent counts -dispersed relative binomial distribution. Counts Beta-binomially distributed, beta distribution shape parameters \\(\\frac{p}{overdispersion}\\) \\(\\frac{1-p}{overdispersion}\\). relatedness probability strain mixed infections related another. Default = 0 (unrelated). implementation similar relatedness defined REAL McCOIL simulations. original paper (https://doi.org/10.1371/journal.pcbi.1005348) defined : \"... simulated relatedness (r) among lineages within host sampling alleles either existing lineage within host (probability r) population (probability (1-r)).\" epsilon probability single read miscalled allele. Applies directions. seq_error level sequencing error assumed. value inputted, infer level sequence error. bin_size minimum size bin data. comparison method employed. One \"end\", \"ideal\", \"overall\". distance distance method used determine distance theoretical simulated curves \"overall\" method. One \"abs_sum\", \"sum_abs\", \"squared\". coi_method method use calculate theoretical COI. method either \"variant\" \"frequency\". default value \"variant\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/cont_sensitivity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Continuous sensitivity analysis — cont_sensitivity","text":"list following: predicted_coi: dataframe predicted COIs. COIs predicted using compute_coi(). column represents separate set parameters. row represents predicted COI. Predictions done many times, depending value repetitions. probability:list matrices containing probability model predicted COI value. row contains probability different run. first row contains average probabilities runs. param_grid: parameter grid. parameter grid possible combinations parameters inputted. row represents unique combination. boot_error: dataframe containing information error algorithm. first column indicates COI fed simulation. columns indicate mean absolute error (mae), lower upper bounds 95% confidence interval bias.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/distance_curves.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute distance between two curves — distance_curves","title":"Compute distance between two curves — distance_curves","text":"Compute distance two curves using several methods. abs_sum Absolute value sum difference. sum_abs Sum absolute difference. squared Sum squared difference.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/distance_curves.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute distance between two curves — distance_curves","text":"","code":"distance_curves(processed_data, theory_cois, distance = \"squared\")"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/distance_curves.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute distance between two curves — distance_curves","text":"theory_cois theoretical COI curves. distance distance method used determine distance theoretical simulated curves \"overall\" method. One \"abs_sum\", \"sum_abs\", \"squared\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/distance_curves.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute distance between two curves — distance_curves","text":"list following: coi predicted COI simulation. dist distance theoretical COI simulated COI curve.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/error_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Error plot — error_plot","title":"Error plot — error_plot","text":"Creates plot showing error sensitivity analysis.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/error_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Error plot — error_plot","text":"","code":"error_plot(   data,   fill = \"coi\",   fill_levels = NULL,   title = NULL,   legend_title = fill,   legend.position = \"right\",   second_fill = NULL )"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/error_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Error plot — error_plot","text":"data data plotted. fill variable data separated . fill_levels levels fill variable. title title plot. Default NULL. legend_title text legend. Default NULL. legend.position position legend. One \"none\", \"left\", \"right\", \"bottom\", \"top\". second_fill Indicates second fill variable .","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/error_plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Error plot — error_plot","text":"function takes output sensitivity(). Plots created using ggplot2::geom_col(), creates simple bar plot. mean absolute error plotted various colors, according parameter tested. addition 95% confidence interval shown black vertical lines.","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/example_real_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Example real data — example_real_data","title":"Example real data — example_real_data","text":"small example dataset contains within-sample allele frequencies (WSAFs) sample individuals.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/example_real_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example real data — example_real_data","text":"matrix data. rows matrix indicate sample name columns matrix indicate WSAF locus.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/example_real_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example real data — example_real_data","text":"ftp://ngs.sanger.ac.uk/production/malaria/pfcommunityproject/Pf6/","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/likelihood.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood of a COI — likelihood","title":"Likelihood of a COI — likelihood","text":"function generate likelihood specific COI value.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/likelihood.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood of a COI — likelihood","text":"","code":"likelihood(coi, processed_data, distance = \"squared\", coi_method = \"variant\")"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/likelihood.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood of a COI — likelihood","text":"coi COI likelihood generated. processed_data processed COI data. output process_sim() process_real(). distance distance method used determine distance theoretical simulated curves \"overall\" method. One \"abs_sum\", \"sum_abs\", \"squared\". coi_method method use calculate theoretical COI. method either \"variant\" \"frequency\". default value \"variant\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/likelihood.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood of a COI — likelihood","text":"likelihood specific COI value.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/likelihood.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Likelihood of a COI — likelihood","text":"likelihood can thought distance two curves: \"real\" COI curve, generated inputted data, \"simulated\" COI curve, depends COI value specified. three different methods implemented compute distance two curves: abs_sum: Absolute value sum difference. sum_abs: Sum absolute difference. squared: Sum squared difference.","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/optimize_coi.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimize the COI — optimize_coi","title":"Optimize the COI — optimize_coi","text":"function compute COI inputted data.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/optimize_coi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimize the COI — optimize_coi","text":"","code":"optimize_coi(   data,   data_type,   max_coi = 25,   seq_error = NULL,   bin_size = 20,   distance = \"squared\",   coi_method = \"variant\" )"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/optimize_coi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimize the COI — optimize_coi","text":"data data COI computed. data_type type data analyzed. One \"sim\" \"real\". max_coi number indicating maximum COI compare simulated data . seq_error level sequencing error assumed. value inputted, infer level sequence error. bin_size minimum size bin data. distance distance method used determine distance theoretical simulated curves \"overall\" method. One \"abs_sum\", \"sum_abs\", \"squared\". coi_method method use calculate theoretical COI. method either \"variant\" \"frequency\". default value \"variant\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/optimize_coi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimize the COI — optimize_coi","text":"predicted COI value.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/optimize_coi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimize the COI — optimize_coi","text":"function utilizes stats::optim() particular, function utilizes quasi-Newton method compute gradients build picture surface optimized. function uses likelihood function defined likelihood().","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process.html","id":null,"dir":"Reference","previous_headings":"","what":"Process data — process","title":"Process data — process","text":"Helper function process data","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process data — process","text":"","code":"process(wsaf, plaf, seq_error = NULL, bin_size = 20, coi_method = \"variant\")"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process data — process","text":"wsaf within-sample allele frequency. plaf population-level allele frequency. seq_error level sequencing error assumed. value inputted, infer level sequence error. bin_size minimum size bin data. coi_method method use calculate theoretical COI. method either \"variant\" \"frequency\". default value \"variant\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process data — process","text":"list following: data: tibble plaf_cut: Breaks form [, b). m_variant: average WSAF proportion variant sites segment defined plaf_cut. bucket_size: number loci bucket. midpoints: midpoint bucket. seq_error: sequence error inferred. bin_size: minimum size bin. cuts: breaks utilized splitting data. COI.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Process data — process","text":"function computes whether SNP variant site , based simulated WSAF SNP. process additionally accounts potential sequencing error.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process_real.html","id":null,"dir":"Reference","previous_headings":"","what":"Process real data — process_real","title":"Process real data — process_real","text":"Generate COI curve real data.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process_real.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process real data — process_real","text":"","code":"process_real(   wsaf,   plaf,   seq_error = NULL,   bin_size = 20,   coi_method = \"variant\" )"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process_real.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process real data — process_real","text":"wsaf within-sample allele frequency. plaf population-level allele frequency. seq_error level sequencing error assumed. value inputted, infer level sequence error. bin_size minimum size bin data. coi_method method use calculate theoretical COI. method either \"variant\" \"frequency\". default value \"variant\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process_real.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process real data — process_real","text":"list following: data: tibble plaf_cut: Breaks form [, b). m_variant: average WSAF proportion variant sites segment defined plaf_cut. bucket_size: number loci bucket. midpoints: midpoint bucket. seq_error: sequence error inferred. bin_size: minimum size bin. cuts: breaks utilized splitting data. COI.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process_real.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Process real data — process_real","text":"function computes whether SNP variant site , based simulated WSAF SNP. process additionally accounts potential sequencing error.","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process_sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Process simulated data — process_sim","title":"Process simulated data — process_sim","text":"Generate simulated COI curve.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process_sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process simulated data — process_sim","text":"","code":"process_sim(sim, seq_error = NULL, bin_size = 20, coi_method = \"variant\")"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process_sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process simulated data — process_sim","text":"sim Output sim_biallelic(). seq_error level sequencing error assumed. value inputted, infer level sequence error. bin_size minimum size bin data. coi_method method use calculate theoretical COI. method either \"variant\" \"frequency\". default value \"variant\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process_sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process simulated data — process_sim","text":"list following: data: tibble plaf_cut: Breaks form [, b). m_variant: average WSAF proportion variant sites segment defined plaf_cut. bucket_size: number loci bucket. midpoints: midpoint bucket. seq_error: sequence error inferred. bin_size: minimum size bin. cuts: breaks utilized splitting data. COI.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/process_sim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Process simulated data — process_sim","text":"Utilize output sim_biallelic(), creates simulated data. PLAF kept, function computes whether SNP variant site , based simulated WSAF SNP. process additionally accounts potential sequencing error. check whether simulated WSAF correctly indicated variant site , phased haplotype parasites computed.","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/rbetabinom.html","id":null,"dir":"Reference","previous_headings":"","what":"Beta-binomial distribution — rbetabinom","title":"Beta-binomial distribution — rbetabinom","text":"Draw Beta-binomial distribution.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/rbetabinom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Beta-binomial distribution — rbetabinom","text":"","code":"rbetabinom(n = 1, k = 10, alpha = 1, beta = 1)"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/rbetabinom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Beta-binomial distribution — rbetabinom","text":"n Number draws. k Number binomial trials. alpha First shape parameter beta distribution. beta Second shape parameter beta distribution.","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/rbetabinom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Beta-binomial distribution — rbetabinom","text":"","code":"coiaf:::rbetabinom() #> [1] 6 coiaf:::rbetabinom(n = 10, k = 10) #>  [1]  9  9  5  8  7  5  2 10  8  0"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/rdirichlet.html","id":null,"dir":"Reference","previous_headings":"","what":"Dirichlet distribution — rdirichlet","title":"Dirichlet distribution — rdirichlet","text":"Draw Dirichlet distribution given vector shape parameters. number observations inferred length shape vector.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/rdirichlet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dirichlet distribution — rdirichlet","text":"","code":"rdirichlet(shape = rep(1, 3))"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/rdirichlet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dirichlet distribution — rdirichlet","text":"shape Vector shape parameters.","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/rdirichlet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dirichlet distribution — rdirichlet","text":"","code":"coiaf:::rdirichlet(c(1, 1, 1)) #> [1] 0.01426034 0.17902465 0.80671500 coiaf:::rdirichlet(c(1, 3, 2)) #> [1] 0.3647833 0.1799719 0.4552448"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sensitivity.html","id":null,"dir":"Reference","previous_headings":"","what":"Sensitivity analysis — sensitivity","title":"Sensitivity analysis — sensitivity","text":"Runs several iterations full COI sensitivity analysis varying parameters.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sensitivity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sensitivity analysis — sensitivity","text":"","code":"sensitivity(   repetitions = 10,   coi = 3,   max_coi = 25,   plaf = runif(1000, 0, 0.5),   coverage = 200,   alpha = 1,   overdispersion = 0,   relatedness = 0,   epsilon = 0,   seq_error = NULL,   bin_size = 20,   comparison = \"overall\",   distance = \"squared\",   coi_method = \"variant\" )"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sensitivity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sensitivity analysis — sensitivity","text":"repetitions number times sample run. coi Complexity infection. max_coi number indicating maximum COI compare simulated data . plaf Vector population-level allele frequencies locus. coverage Coverage locus. single value coverage applied loci. alpha Shape parameter symmetric Dirichlet prior strain proportions. overdispersion extent counts -dispersed relative binomial distribution. Counts Beta-binomially distributed, beta distribution shape parameters \\(\\frac{p}{overdispersion}\\) \\(\\frac{1-p}{overdispersion}\\). relatedness probability strain mixed infections related another. Default = 0 (unrelated). implementation similar relatedness defined REAL McCOIL simulations. original paper (https://doi.org/10.1371/journal.pcbi.1005348) defined : \"... simulated relatedness (r) among lineages within host sampling alleles either existing lineage within host (probability r) population (probability (1-r)).\" epsilon probability single read miscalled allele. Applies directions. seq_error level sequencing error assumed. value inputted, infer level sequence error. bin_size minimum size bin data. comparison method employed. One \"end\", \"ideal\", \"overall\". distance distance method used determine distance theoretical simulated curves \"overall\" method. One \"abs_sum\", \"sum_abs\", \"squared\". coi_method method use calculate theoretical COI. method either \"variant\" \"frequency\". default value \"variant\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sensitivity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sensitivity analysis — sensitivity","text":"list following: predicted_coi: dataframe predicted COIs. COIs predicted using compute_coi(). column represents separate set parameters. row represents predicted COI. Predictions done many times, depending value repetitions. probability:list matrices containing probability model predicted COI value. row contains probability different run. first row contains average probabilities runs. param_grid: parameter grid. parameter grid possible combinations parameters inputted. row represents unique combination. boot_error: dataframe containing information error algorithm. first column indicates COI fed simulation. columns indicate mean absolute error (mae), lower upper bounds 95% confidence interval bias.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sensitivity_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Sensitivity plot — sensitivity_plot","title":"Sensitivity plot — sensitivity_plot","text":"Creates plot sensitivity analysis.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sensitivity_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sensitivity plot — sensitivity_plot","text":"","code":"sensitivity_plot(   data,   dims,   result_type,   sub_title = NULL,   title = NULL,   caption = NULL )"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sensitivity_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sensitivity plot — sensitivity_plot","text":"data data plotted. dims list representing number rows columns plots split . result_type indicator indicates count boxplot plotted. sub_title list titles individual subplot. title title overall figure. caption caption overall figure.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sensitivity_plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sensitivity plot — sensitivity_plot","text":"function takes output sensitivity() creates grid plots. plot created using ggplot2::geom_count(). number observations location counted count mapped point area plot. x-axis true COI, y-axis estimated COI. counts plotted blue, red line drawn equation \\(y = x\\). line indicates blue circles algorithm 100% correct.","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sensitivity_plot_element.html","id":null,"dir":"Reference","previous_headings":"","what":"Single sensitivity plot — sensitivity_plot_element","title":"Single sensitivity plot — sensitivity_plot_element","text":"Creates single plot sensitivity analysis. Used helper function sensitivity_plot().","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sensitivity_plot_element.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single sensitivity plot — sensitivity_plot_element","text":"","code":"sensitivity_plot_element(data, loop_num, result_type, sub_title)"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sensitivity_plot_element.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Single sensitivity plot — sensitivity_plot_element","text":"data data plotted. loop_num loop number. Represents many total panels plotted. result_type indicator indicates count boxplot plotted. sub_title list titles individual subplot.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sim_biallelic.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate biallelic data — sim_biallelic","title":"Simulate biallelic data — sim_biallelic","text":"Simulate biallelic data simple statistical model. Inputs include complexity infection (COI), population-level allele frequencies (PLAF), parameters dictating skew error distributions. Outputs include phased haplotypes unphased read count coverage data.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sim_biallelic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate biallelic data — sim_biallelic","text":"","code":"sim_biallelic(   coi = 3,   plaf = runif(10, 0, 0.5),   coverage = 200,   alpha = 1,   overdispersion = 0,   relatedness = 0,   epsilon = 0 )"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sim_biallelic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate biallelic data — sim_biallelic","text":"coi Complexity infection. plaf Vector population-level allele frequencies locus. coverage Coverage locus. single value coverage applied loci. alpha Shape parameter symmetric Dirichlet prior strain proportions. overdispersion extent counts -dispersed relative binomial distribution. Counts Beta-binomially distributed, beta distribution shape parameters \\(\\frac{p}{overdispersion}\\) \\(\\frac{1-p}{overdispersion}\\). relatedness probability strain mixed infections related another. Default = 0 (unrelated). implementation similar relatedness defined REAL McCOIL simulations. original paper (https://doi.org/10.1371/journal.pcbi.1005348) defined : \"... simulated relatedness (r) among lineages within host sampling alleles either existing lineage within host (probability r) population (probability (1-r)).\" epsilon probability single read miscalled allele. Applies directions.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sim_biallelic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate biallelic data — sim_biallelic","text":"list : coi: COI used simulate data. strain_proportions: strain proportion strain. phased: phased haplotype. data: dataframe : plaf: population-level allele frequency. coverage: coverage locus. counts: count locus. wsaf: within-sample allele frequency. inputs: dataframe function input arguments: alpha: Shape parameters Dirichlet controlling strain proportions. overdispersion: Overdispersion count data. relatedness: Within sample relatedness strains. epsilon: Probability single read miscalled.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/sim_biallelic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate biallelic data — sim_biallelic","text":"Simulated data drawn simple statistical model: Strain proportions drawn symmetric Dirichlet distribution shape parameter alpha. Phased haplotypes drawn every locus, one coi. allele locus drawn Bernoulli distribution probability given plaf. \"true\" within-sample allele frequency every locus obtained multiplying haplotypes strain proportions, summing haplotypes. Errors introduced equation \\[wsaf_{error} = wsaf(1-e) + (1-wsaf)e\\] \\(wsaf\\) WSAF without error \\(e\\) error parameter epsilon. Final read counts drawn beta-binomial distribution expectation \\(w_{error}\\). raw number draws given coverage, skew distribution given overdispersion parameter. overdispersion equal zero, distribution binomial, rather beta-binomial.","code":""},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/single_sensitivity.html","id":null,"dir":"Reference","previous_headings":"","what":"Single sensitivity analysis — single_sensitivity","title":"Single sensitivity analysis — single_sensitivity","text":"Runs single full COI sensitivity analysis.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/single_sensitivity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single sensitivity analysis — single_sensitivity","text":"","code":"single_sensitivity(   coi = 3,   max_coi = 25,   plaf = runif(1000, 0, 0.5),   coverage = 200,   alpha = 1,   overdispersion = 0,   relatedness = 0,   epsilon = 0,   seq_error = NULL,   bin_size = 20,   comparison = \"overall\",   distance = \"squared\",   coi_method = \"variant\" )"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/single_sensitivity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Single sensitivity analysis — single_sensitivity","text":"coi Complexity infection. max_coi number indicating maximum COI compare simulated data . plaf Vector population-level allele frequencies locus. coverage Coverage locus. single value coverage applied loci. alpha Shape parameter symmetric Dirichlet prior strain proportions. overdispersion extent counts -dispersed relative binomial distribution. Counts Beta-binomially distributed, beta distribution shape parameters \\(\\frac{p}{overdispersion}\\) \\(\\frac{1-p}{overdispersion}\\). relatedness probability strain mixed infections related another. Default = 0 (unrelated). implementation similar relatedness defined REAL McCOIL simulations. original paper (https://doi.org/10.1371/journal.pcbi.1005348) defined : \"... simulated relatedness (r) among lineages within host sampling alleles either existing lineage within host (probability r) population (probability (1-r)).\" epsilon probability single read miscalled allele. Applies directions. seq_error level sequencing error assumed. value inputted, infer level sequence error. bin_size minimum size bin data. comparison method employed. One \"end\", \"ideal\", \"overall\". distance distance method used determine distance theoretical simulated curves \"overall\" method. One \"abs_sum\", \"sum_abs\", \"squared\". coi_method method use calculate theoretical COI. method either \"variant\" \"frequency\". default value \"variant\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/single_sensitivity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Single sensitivity analysis — single_sensitivity","text":"Predicted COI value.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/single_theoretical_coi.html","id":null,"dir":"Reference","previous_headings":"","what":"Single Theoretical COI — single_theoretical_coi","title":"Single Theoretical COI — single_theoretical_coi","text":"Generate theoretical COI curve particular COI value.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/single_theoretical_coi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single Theoretical COI — single_theoretical_coi","text":"","code":"single_theoretical_coi(   coi,   plaf = seq(0, 0.5, l = 101),   coi_method = \"variant\" )"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/single_theoretical_coi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Single Theoretical COI — single_theoretical_coi","text":"coi COI curve calculated. plaf PLAF curve calculated. coi_method method use calculate theoretical COI. method either \"variant\" \"frequency\". default value \"variant\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/single_theoretical_coi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Single Theoretical COI — single_theoretical_coi","text":"theoretical COI curve specified PLAF.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/single_theoretical_coi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Single Theoretical COI — single_theoretical_coi","text":"theoretical curve can visualized WSAF individual various PLAFs. locus, theoretical COI defined : \\[1-p^{coi}-q^{coi}\\]","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/theme_coiaf.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom ggplot2 theme — theme_coiaf","title":"Custom ggplot2 theme — theme_coiaf","text":"Custom ggplot2 theme","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/theme_coiaf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom ggplot2 theme — theme_coiaf","text":"","code":"theme_coiaf(   base_size = 10,   base_family = \"\",   base_line_size = base_size/22,   base_rect_size = base_size/22 )"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/theme_coiaf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Custom ggplot2 theme — theme_coiaf","text":"base_size base font size, given pts. base_family base font family base_line_size base size line elements base_rect_size base size rect elements","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/theme_coiaf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Custom ggplot2 theme — theme_coiaf","text":"","code":"library(\"ggplot2\") p <- ggplot(mtcars, aes(x = wt, y = mpg, colour = factor(gear))) +   geom_point() +   facet_wrap(~am) +   geom_smooth(method = \"lm\", se = FALSE)  p + theme_coiaf() #> `geom_smooth()` using formula 'y ~ x'"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/theoretical_coi.html","id":null,"dir":"Reference","previous_headings":"","what":"Theoretical COI — theoretical_coi","title":"Theoretical COI — theoretical_coi","text":"Generate theoretical COI curves.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/theoretical_coi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Theoretical COI — theoretical_coi","text":"","code":"theoretical_coi(coi_range, plaf = seq(0, 0.5, l = 101), coi_method = \"variant\")"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/theoretical_coi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Theoretical COI — theoretical_coi","text":"coi_range COIs curve calculated. plaf PLAF curve calculated. coi_method method use calculate theoretical COI. method either \"variant\" \"frequency\". default value \"variant\".","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/theoretical_coi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Theoretical COI — theoretical_coi","text":"theoretical COI curves specified COIs PLAF.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/theoretical_coi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Theoretical COI — theoretical_coi","text":"theoretical curve can visualized WSAF individual various PLAFs. locus, theoretical COI defined : \\[1-p^{coi}-q^{coi}\\] \\(p\\) PLAF \\(q\\) 1 - PLAF.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/tidyeval.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy eval helpers — tidyeval","title":"Tidy eval helpers — tidyeval","text":"page lists tidy eval tools reexported package rlang. learn using tidy eval scripts packages high level, see dplyr programming vignette ggplot2 packages vignette. Metaprogramming section Advanced R may also useful deeper dive. tidy eval operators {{, !!, !!! syntactic constructs specially interpreted tidy eval functions. mostly need {{, !! !!! advanced operators use simple cases. curly-curly operator {{ allows tunnel data-variables passed function arguments inside tidy eval functions. {{ designed individual arguments. pass multiple arguments contained dots, use ... normal way. enquo() enquos() delay execution one several function arguments. former returns single expression, latter returns list expressions. defused, expressions longer evaluate . must injected back evaluation context !! (single expression) !!! (list expressions). simple case, code equivalent usage {{ ... . Defusing enquo() enquos() needed complex cases, instance need inspect modify expressions way. .data pronoun object represents current slice data. variable name string, use .data pronoun subset variable [[. Another tidy eval operator :=. makes possible use glue curly-curly syntax LHS =. technical reasons, R language support complex expressions left =, use := workaround. Many tidy eval functions like dplyr::mutate() dplyr::summarise() give automatic name unnamed inputs. need create sort automatic names , use as_label(). instance, glue-tunnelling syntax can reproduced manually : Expressions defused enquo() (tunnelled {{) need simple column names, can arbitrarily complex. as_label() handles cases gracefully. code assumes simple column name, use as_name() instead. safer throws error input name expected.","code":"my_function <- function(data, var, ...) {   data %>%     group_by(...) %>%     summarise(mean = mean({{ var }})) } my_function <- function(data, var, ...) {   # Defuse   var <- enquo(var)   dots <- enquos(...)    # Inject   data %>%     group_by(!!!dots) %>%     summarise(mean = mean(!!var)) } my_var <- \"disp\" mtcars %>% summarise(mean = mean(.data[[my_var]])) my_function <- function(data, var, suffix = \"foo\") {   # Use `{{` to tunnel function arguments and the usual glue   # operator `{` to interpolate plain strings.   data %>%     summarise(\"{{ var }}_mean_{suffix}\" := mean({{ var }})) } my_function <- function(data, var, suffix = \"foo\") {   var <- enquo(var)   prefix <- as_label(var)   data %>%     summarise(\"{prefix}_mean_{suffix}\" := mean(!!var)) }"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/world_map.html","id":null,"dir":"Reference","previous_headings":"","what":"World map plot — world_map","title":"World map plot — world_map","text":"Plot world map showing COI region reads sampled .","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/world_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"World map plot — world_map","text":"","code":"world_map(data, variable, label = NULL, alpha = 0.1, breaks = c(1, 2))"},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/world_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"World map plot — world_map","text":"data data plotted. variable variable data plot. label label variable. alpha alpha value plotted data. breaks breaks color scale.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/reference/world_map.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"World map plot — world_map","text":"Creates world map overlays COI region. magnitude COI indicated color size bubble.","code":""},{"path":[]},{"path":[]},{"path":"https://bailey-lab.github.io/coiaf/dev/news/index.html","id":"new-vignettes-development-version","dir":"Changelog","previous_headings":"","what":"New vignettes","title":"coiaf (development version)","text":"New vignette(\"example_real_data\") illustrates use package real data sets. New vignette(\"sensitivity_analysis_discrete\") describes sensitivity analysis discrete methods. New vignette(\"sensitivity_analysis_continuous\") describes sensitivity analysis continuous methods. New vignette(\"example_coi_prediction\") explains internal prediction methods. New vignette(\"example_simulation\") explains data simulated.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/news/index.html","id":"new-features-development-version","dir":"Changelog","previous_headings":"","what":"New features","title":"coiaf (development version)","text":"New theme_coiaf() creates custom theme package.","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/news/index.html","id":"maintenance-development-version","dir":"Changelog","previous_headings":"","what":"Maintenance","title":"coiaf (development version)","text":"number dependencies reduced. patchwork used instead ggpubr combining plots. rlang now used messages, warnings, errors. Superseded functions replaced alternatives (#6). Functions now exit implicitly visibly (#8). Internal documentation improved. COI methods renamed improved clarity. \"Method 1\" renamed \"Variant Method\" \"Method 2\" renamed \"Frequency Method\" (#9).","code":""},{"path":"https://bailey-lab.github.io/coiaf/dev/news/index.html","id":"coiaf-010","dir":"Changelog","previous_headings":"","what":"coiaf 0.1.0","title":"coiaf 0.1.0","text":"Initial public release.","code":""}]
