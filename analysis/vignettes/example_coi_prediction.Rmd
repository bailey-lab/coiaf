---
title: "Example COI Prediction"
author: "Oliver Watson, Aris Paschalidis"
date: "`r format(Sys.time(), '%B %Y')`"
output: rmarkdown::html_vignette
vignette: >
 %\VignetteIndexEntry{Example COI Prediction}
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  fig.width = 7, 
  fig.height = 7
)

library(coiaf)
```

In this analysis the two COI estimation methods are demonstrated. In these we 
will simulate 1000 loci for an individual. We first initialize the population
level allele frequency (PLAF) using a beta distribution.

```{r initialize PLAF}
# Set seed
set.seed(1)

# Define the number of loci and the distribution of minor allele frequencies
L <- 1e3
p <- stats::rbeta(L, 1, 5)
p[p > 0.5] <- 1 - p[p > 0.5]
```


## Method 1

The first approach in the manuscript document for estimating COI is shown below. 
This works by using the mean number of variant sites, binned in groups of 
increasing PLAF to infer COI.

```{r method 1}
# Loop over range of COIs 
end_coi = list()
opt_coi = list()
par(mar = c(4, 4, 4, 4))
par(mfrow = c(3, 2))
for (k in 2:7) {

  # Simulate data and subset to heterozygous sites only
  set.seed(1)
  sim1 <- sim_biallelic(coi = k, plaf = p)

  # Plot raw WSAF as gray dots
  plot(sim1$data$plaf, sim1$data$wsaf, 
       pch = 20, cex = 0.5, col = "gray", ylim = c(0,1),
       xlab = "PLAF", ylab = "WSAF", main = paste("COI =", k))

  # Overlay analytical expectations for COI of 2:7
  p_vec <- seq(0, 0.5, l=101)
  theory_cois <- theoretical_coi(seq(1, 7), p_vec)
  for (i in 1:7) {
    lines(p_vec, theory_cois[[paste("coi_", i, sep = "")]], 
          col = "red", lwd = 2)
  }
  text(x = rep(0.505, 6), y = 1 - 0.5^(1:6), labels = 1:7, 
       col = "red", cex = 0.6)

  # Compute windowed averages over WSAF and overlay in blue
  cut <- seq(0,0.5,0.01)
  df_grouped <- process_sim(sim1, cut = cut)

  lines(df_grouped$midpoints, df_grouped$m_variant, 
        col = "blue", lwd = 2, type = "o", pch = 20)
  
  # Predict the COI and print the results
  calc_coi = compute_coi(sim1, "sim", max_coi = 10, cut = cut)
  end_coi = unlist(c(end_coi, calc_coi$coi))
  
  # COI using optimization
  add = optimize_coi(sim1, "sim", max_coi = 10, cut = cut)
  opt_coi = unlist(c(opt_coi, add))
}
```

In this, the intercept at `PLAF = 0.5` gives us an easy way to estimate COI, 
with `COI = 1 + log_0.5(1-WSAF)`, or `WSAF = 1 - 0.5^(COI-1)`. However, the 
differences between each COI at PLAF = 0.5 become geometrically smaller. Larger 
gaps can be found at different COI, with smaller PLAF:

```{r ideal PLAF}
par(mar = c(4, 4, 4, 4))
par(mfrow = c(3, 3))
p_vec <- seq(0, 0.5, l=101)
y <- list()
for (k in 1:10) {
  y[[k]] <- theoretical_coi(k, p_vec)[[1]]

  if(k > 1) {
   new_y <- y[[k]]-y[[k-1]]
   plot(p_vec, new_y,
        ylab = glue::glue("Difference between COI {k-1} and {k}"),
        xlab = "PLAF",
        main = paste("COI = ", k))
   abline(v=p_vec[which.max(new_y)], lty = 2)
   text(x=p_vec[which.max(new_y)] - 0.02, y = 0.0, 
        labels = p_vec[which.max(new_y)])
  }
}
```

## Method 2

In method 2, we plot WSAF against PLAF for only the sites that are 
heterogeneous, i.e. not all REF or ALT calls. 

```{r method 2}
# loop over range of COIs
disc_coi = list()
cont_coi = list()
par(mar = c(4, 4, 4, 4))
par(mfrow = c(3,2))
for (k in 2:7) {

  # simulate data and subset to heterozygous sites only
  set.seed(10)
  sim1 <- sim_biallelic(coi = k, plaf = p)
  sim1$data <- subset(sim1$data, wsaf > 0 & wsaf < 1)

  # plot raw WSAF as grey dots
  plot(sim1$data$plaf, sim1$data$wsaf, pch = 20, cex = 0.5, col = "gray", 
       ylim = c(0,1), xlab = "PLAF", ylab = "WSAF", main = paste("COI =", k))

  # overlay analytical expectations for COI=2:7
  p_vec <- seq(0, 0.5, l=101)
  theory_cois <- theoretical_coi(seq(1, 7), p_vec, coi_method = "2")
  for (i in 2:7) {
    lines(p_vec, theory_cois[[paste("coi_", i, sep = "")]], col = 2, lwd = 2)
  }
  text(x = rep(-0.005, 6), y = 1/2:7, labels = 2:7, col = "red", cex = 0.6)

  # compute sliding-window averages over WSAF and overlay in blue
  cut_breaks <- seq(0, 0.5, 0.025)
  df_grouped <- process_sim(sim1, 0.01, cut_breaks, coi_method = "2")

  lines(df_grouped$midpoints, df_grouped$m_variant,
        col = "blue", lwd = 2, type = "o", pch = 20)
  
  # Predict the COI and print the results
  disc = compute_coi(sim1, "sim", max_coi = 10, cut = cut_breaks, coi_method = "2")
  disc_coi = unlist(c(disc_coi, disc$coi))
  
  # COI using optimization
  cont = optimize_coi(sim1, "sim", max_coi = 10, cut = cut_breaks, coi_method = "2", seq_error = 0.01)
  cont_coi = unlist(c(cont_coi, cont))
}
```

In this case, COI is found as 1/WSAF when PLAF = 0 (i.e. the y-axis intercept).

## Figure 1
```{r ggplot2 attempt, warning = F}
library(ggplot2)

set.seed(4)
sim <- sim_biallelic(coi = 4, plaf = p)
p_vec <- seq(0, 0.5, l=101)

mytheme <- list(theme_classic(), 
  theme(text = element_text(family = "Times New Roman"),
        plot.title = element_text(hjust = 0.5, size = 10),
        axis.title = element_text(size = 8),
        legend.position = "bottom",
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8)))

method1 <- ggplot() + 
  geom_point(data = sim$data, aes(x = plaf, y = wsaf)) + 
  geom_line(aes(x = p_vec, y = 1 - p_vec^1 - (1 - p_vec)^1), color = "red") +
  geom_line(aes(x = p_vec, y = 1 - p_vec^2 - (1 - p_vec)^2), color = "red") +
  geom_line(aes(x = p_vec, y = 1 - p_vec^3 - (1 - p_vec)^3), color = "red") +
  geom_line(aes(x = p_vec, y = 1 - p_vec^4 - (1 - p_vec)^4), color = "red") +
  geom_line(aes(x = p_vec, y = 1 - p_vec^5 - (1 - p_vec)^5), color = "red") +
  annotate(geom = "text", x = 0.505, y = 1 - 0.5^(0:4), 
           label = c("1", "2", "3", "4", "5"), col = "red", size = 7 / .pt) +
  mytheme +
  labs(x = "PLAF", y = "WSAF", title = "Method 1")

method2 <- ggplot() + 
  geom_point(data = sim$data, aes(x = plaf, y = wsaf)) + 
  geom_line(aes(x = p_vec, y = (p_vec - p_vec^2)/(1 - p_vec^2 - (1 - p_vec)^2)), 
                color = "red") +
  geom_line(aes(x = p_vec, y = (p_vec - p_vec^3)/(1 - p_vec^3 - (1 - p_vec)^3)), 
                color = "red") +
  geom_line(aes(x = p_vec, y = (p_vec - p_vec^4)/(1 - p_vec^4 - (1 - p_vec)^4)), 
                color = "red") +
  geom_line(aes(x = p_vec, y = (p_vec - p_vec^5)/(1 - p_vec^5 - (1 - p_vec)^5)), 
                color = "red") +
  geom_line(aes(x = p_vec, y = (p_vec - p_vec^6)/(1 - p_vec^6 - (1 - p_vec)^6)), 
                color = "red") +
  annotate(geom = "text", x = -0.005, y = 1/2:6, 
           label = c("2", "3", "4", "5", "6"), col = "red", size = 7 / .pt) +
  mytheme +
  labs(x = "PLAF", y = "WSAF", title = "Method 2")

ggpubr::ggarrange(method1, method2,
                  ncol = 2,
                  labels = "AUTO",
                  font.label = list(size = 10))

# To get the following code to work, must have toverall_images return a list
# of plots
# Figure1 <- c(list(method1, method2), toverall_image)
# ggpubr::ggarrange(ggpubr::ggarrange(plotlist = Figure1,
#                                     nrow = 2, ncol = 2, 
#                                     labels = "AUTO", 
#                                     font.label = list(size = 10)), 
#                   toverall_error,
#                   nrow = 2,
#                   heights = c(2, 1),
#                   labels = c("" ,"E"),
#                   font.label = list(size = 10))
```

