---
title: "Example COI Prediction"
author: "Aris Paschalidis"
date: "`r format(Sys.time(), '%B %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Example COI Prediction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 80)
)

library(coiaf)
```

In this analysis the two COI estimation methods are demonstrated. In these we 
will simulate 1000 loci for an individual. We first initialize the population
level allele frequency (PLAF) using a beta distribution.

```{r initialize PLAF}
# Set seed
set.seed(1)

# Define the number of loci and the distribution of minor allele frequencies
L <- 1e3
p <- stats::rbeta(L, 1, 5)
p[p > 0.5] <- 1 - p[p > 0.5]
```


# Method 1

The first approach in the manuscript document for estimating COI is shown below. 
This works by using the mean number of variant sites, binned in groups of 
increasing PLAF to infer COI.

```{r method 1}
# Loop over range of COIs 
end_coi = list()
par(mar=c(1,1,1,1))
par(mfrow = c(3,2))
for (k in 2:7){

  # Simulate data and subset to heterozygous sites only
  set.seed(1)
  sim1 <- sim_biallelic(COI = k, PLAF = p)

  # Plot raw WSAF as gray dots
  plot(sim1$data$PLAF, sim1$data$WSAF, 
       pch = 20, cex = 0.5, col = "gray", ylim = c(0,1),
       xlab = "PLAF", ylab = "WSAF", main = paste("COI =", k))

  # Overlay analytical expectations for COI of 2:7
  p_vec <- seq(0, 0.5, l=101)
  theory_cois <- theoretical_coi(seq(1, 7), p_vec)
  for (i in 2:7) {
    lines(p_vec, theory_cois[[paste("coi_", i, sep = "")]], 
          col = "red", lwd = 2)
  }
  text(x = rep(0.505, 6), y = 1 - 0.5^(1:6), labels = 2:7, 
       col = "red", cex = 0.6)

  # Compute windowed averages over WSAF and overlay in blue
  cut <- seq(0,0.5,0.01)
  df_grouped <- process_simulated_coi(sim1, 0.01, cut)

  lines(df_grouped$midpoints, df_grouped$m_true_variant, 
        col = "blue", lwd = 2, type = "o", pch = 20)
  
  # Predict the COI and print the results
  calc_coi = compute_coi(df_grouped, seq(1, 7), cut, "overall", "squared", TRUE)
  end_coi = unlist(c(end_coi, calc_coi$coi))
}
```

In this the intercept at `PLAF = 0.5` gives us an easy way to estimate COI, with 
`COI = 1 + log_0.5(1-WSAF)`, or `WSAF = 1 - 0.5^(COI-1)`. However, the 
differences between each COI at PLAF = 0.5 become geometrically smaller. Larger 
gaps can be found at different COI, with smaller PLAF:

```{r ideal PLAF}
## Best place to calculate COI:
par(mar=c(1,1,1,1))
par(mfrow = c(3,3))
p_vec <- seq(0, 0.5, l=101)
y <- list()
for (k in 1:10) {
  y[[k]] <- theoretical_coi(k, p_vec)[[1]]

  if(k>1) {
   new_y <- y[[k]]-y[[k-1]]
   plot(p_vec, new_y,
        ylab = "Difference between Proportion Variant for k and k-1",
        xlab = "Population MAF",
        main = paste("COI = ", k))
   abline(v=p_vec[which.max(new_y)], lty = 2)
   text(x=p_vec[which.max(new_y)] - 0.02, y = 0.0, 
        labels = p_vec[which.max(new_y)])
  }
}
```

# Method 2

In method 2, we plot WSAF against PLAF for only the sites that are 
heterogeneous, i.e. not all REF or ALT calls. 

```{r method 2}
# loop over range of COIs
par(mar=c(1,1,1,1))
par(mfrow = c(3,2))
for (k in 2:7) {

  # simulate data and subset to heterozygous sites only
  # set.seed(1)
  sim1 <- sim_biallelic(COI = k, PLAF = p, overdispersion = 0.01)
  sim1$data <- subset(sim1$data, WSAF > 0 & WSAF < 1)

  # plot raw WSAF as grey dots
  plot(sim1$data$PLAF, sim1$data$WSAF, pch = 20, cex = 0.5, col = "gray", 
       ylim = c(0,1), xlab = "PLAF", ylab = "WSAF", main = paste("COI =", k))

  # overlay analytical expectations for COI=2:7
  p_vec <- seq(0, 0.5, l=101)
  theory_cois <- theoretical_coi(seq(1, 7), p_vec, method = "2")
  for (i in 2:7) {
    lines(p_vec, theory_cois[[paste("coi_", i, sep = "")]], col = 2, lwd = 2)
  }
  text(x = rep(-0.005, 6), y = 1/2:7, labels = 2:7, col = "red", cex = 0.6)

  # compute sliding-window averages over WSAF and overlay in blue
  cut_breaks <- seq(0, 0.5, 0.025)
  cut_mids <- cut_breaks[-1]-diff(cut_breaks)/2
  c <- cut(sim1$data$PLAF, breaks = cut_breaks)
  x2 <- mapply(mean, split(sim1$data$WSAF, f = c))
  lines(cut_mids, x2, col = "blue", lwd = 2, type = "o", pch = 20)
}
```

In this case, COI is found as 1/WSAF when PLAF = 0 (i.e. the y-axis intercept).
