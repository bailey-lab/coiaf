---
title: "Benchmarks"
author: "Aris Paschalidis"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# devtools::install_github("OJWatson/McCOILR")
library(McCOILR)
library(coiaf)
```

# Comparing the two {coiaf} methods
```{r function definitions}
# Set seed
set.seed(101)

# Create function to take variable coi and # of loci
create_data <- function(coi, n_loci) {
  plaf <- stats::rbeta(n_loci, 1, 5)
  plaf[plaf > 0.5] <- 1 - plaf[plaf > 0.5]

  sim_biallelic(coi = coi, plaf = plaf)
}
```

```{r disc vs cont}
results <- bench::press(
  coi = c(1, seq(5, 25, 5)),
  n_loci = c(100, 1000, 5000, 10000),
  {
    dat <- create_data(coi, n_loci)
    bench::mark(
      min_iterations = 10,
      discrete = compute_coi(dat, "sim", max_coi = 50),
      continuous = optimize_coi(dat, "sim", max_coi = 50),
      check = FALSE
    )
  }
)

results

ggplot2::autoplot(results)
```
From these results, we can see that for small numbers of loci, the discrete
method is almost twice as fast as the continuous method. However, as the number
of loci increases, this difference becomes smaller. There is consistently a
difference in median speed of around 20 ms.

```{r coiaf vs rmcl}
set.seed(500)

n_loci <- 1000
n_samples <- 100
missingness <- 0.05
coi <- as.integer(runif(n_samples, 1, 10))
plaf <- runif(n_loci, 0, 0.5)

# create genotype matrix for this using sim biallelic
f <- lapply(seq_len(n_samples), function(x) {
  coiaf::sim_biallelic(coi[x], plaf, epsilon = 0.05)
})

# now let's create out genotype matrix for RMCL
gts <- lapply(f, function(x) {
  gtmat <- x$data$wsaf
  gtmat[gtmat >= 0.95] <- 1
  gtmat[gtmat <= 0.05] <- 1
  gtmat[gtmat < 0.95 & gtmat > 0.05] <- 0.5
  gtmat[which(as.logical(rbinom(100, 1, 0.05)))] <- -1
  return(gtmat)
})

# group together to get out gtmat
gtmat <- do.call(rbind, gts)
rownames(gtmat) <- letters[seq_len(nrow(gtmat))]
colnames(gtmat) <- paste0("pos_", seq_len(ncol(gtmat)))
gtmat <- as.data.frame(gtmat)

# Run RMCL categorical
tf <- "test.txt"
td <- tempdir()
runs <- 50000

bench::system_time(
  out_a <- McCOIL_categorical(
    data = gtmat,
    maxCOI = 25,
    totalrun = runs,
    burnin = 1000,
    M0 = 5,
    threshold_ind = round(ncol(gtmat) * 0.25),
    threshold_site = round(nrow(gtmat) * 0.20),
    err_method = 3,
    thin = 0.1,
    path = td,
    output = tf
  )
)
out_b <- McCOIL_categorical(
  data = gtmat,
  maxCOI = 25,
  totalrun = runs,
  burnin = 1000,
  M0 = 5,
  threshold_ind = round(ncol(gtmat) * 0.25),
  threshold_site = round(nrow(gtmat) * 0.20),
  err_method = 3,
  thin = 0.1,
  path = td, output = tf
)

# check for convergence between runs are they close? - yes
cbind(
  head(as.integer(out_a$median), n_samples),
  head(as.integer(out_b$median), n_samples)
)

# what is the error look like
hist(coi - head(as.integer(out_a$median), n_samples))

# mean error of 5 and took 12.5 seconds (correct to halve running time)
mean(coi - head(as.integer(out_a$median), n_samples))

# Run COIAF
bench::system_time(
  out2 <- lapply(f, coiaf::compute_coi, "sim", max_coi = 25)
)

# takes 0.3 seconds, mean error 0.2
hist(coi - unlist(lapply(out2, "[[", "coi")))
mean(coi - unlist(lapply(out2, "[[", "coi")))
```
